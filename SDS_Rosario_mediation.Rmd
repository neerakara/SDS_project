---
title: "SDS_project_final"
output: html_document
---


## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

#Install libraries
```{r}
# ========================================================================
# The World Bank was founded in 1944 with the goal of reducing poverty in the world. 
# One of its functions is to keep track of the economic development of many countries.
# The world bank provides country-wise data about several indicators via this interface: https://databank.worldbank.org/
# ========================================================================

# ========================================================================
# If not already done, install and load the WDI package.
# ========================================================================
if(!require(WDI)){
  install.packages("WDI")

}
install.packages("tidyverse")


install.packages("mediation")


install.packages("readxl")


install.packages("stringr")

install.packages("tidyr")

``` 
#Library declaration
```{r}
library(stringr)
library(tidyverse)
library(mediation)
library(readxl)
library(tidyr)
library(WDI)
``` 
# List of countries.
```{r}
# ========================================================================
# The WDI package
#    downloads the requested data by using the World Bank's API,
#    parses the resulting XML file,
#    and formats it in long country-year format.
# ========================================================================

# ========================================================================
# Set parameters to define the queries to the WDI package
# ========================================================================

# ==========================================
# List of countries.
# Let us consider all European countries.
# Searched the ISO country codes from here: https://www.iban.com/country-codes
#  
#  	 	 
#  	 	 	
#  		
#  	 	 	
#  	


# ==========================================
countries <- c("AT", # Austria
               "BE", # Belgium
               "BG", # Bulgaria
               "CY", # Cyprus
               "CZ", # Czech Republic
               "DE", # Germany
               "DK", # Denmark
               "ES", # Spain
               "EE", # Estonia
               "FI", # Finland
               "FR", # France
               "GR", # Greece
               "HR", # Croatia
               "HU", # Hungary
               "IE", # Ireland
               "IT", # Italy
               "LT", # Lithuania
               "LU", # Luxembourg
               "LV", # Latvia
               "MT", # Malta
               "NL", # Netherlands 
               "PL", # Poland
               "PT", # Portugal
               "RO", # Romania
               "SK", # Slovakia
               "SI", # Slovenia
               "SE"  # Sweden
               )

# ==========================================
# To do the analysis for a subset of the countries, edit and uncomment the following line 
# ==========================================
# countries <- c("NL")
num_countries <- length(countries)
```


# ```{r}
# 
# download.file("https://development-data-hub-s3-public.s3.amazonaws.com/ddhfiles/1202896/industry_migration_public.csv", destfile = "IndustryMigration.csv")
# ```
# 
# ```{r}
# countries_csv <- read.csv("IndustryMigration.csv", header = T, sep = ",", encoding="UTF-8") %>% 
#   filter(wb_region == "Europe & Central Asia")
# 
# countries_list <- countries_csv$X.U.FEFF.country_code 
# countries <- distinct(as_tibble(toupper(countries_list)), .keep_all=TRUE)
# num_countries <- length(countries)
# ```
# Indicators
```{r}
# ==========================================
# Indicators
# gdp growth annual in %
# ==========================================
indicator_gdp_pcap <- "NY.GDP.PCAP.PP.CD"           
indicator_unemployment_total <- "SL.UEM.TOTL.NE.ZS"
indicator_unemployment_youth <- "SL.UEM.1524.NE.ZS"
indicator_unemployment_male <- "SL.UEM.TOTL.MA.NE.ZS"
indicator_unemployment_female <- "SL.UEM.TOTL.FE.NE.ZS"
indicator_employment_agr <- "SL.AGR.EMPL.ZS"
indicator_employment_industry <- "SL.IND.EMPL.ZS"
indicator_employment_services <- "SL.SRV.EMPL.ZS"
```
# Start and end year
```{r}
# ==========================================
# Start and end year
# ==========================================
start_year <- 2015
end_year <- 2019
num_years <- end_year - start_year + 1
num_datapoints <- num_countries * num_years
```
# Get the GDP per capita
```{r}
# ========================================================================
# Get the GDP per capita 
# ========================================================================
gdp_pcap <- WDI(indicator = indicator_gdp_pcap,
                  country = countries,
                  start = start_year,
                  end = end_year)

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(gdp_pcap$NY.GDP.PCAP.PP.CD[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(gdp_pcap$NY.GDP.PCAP.PP.CD[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_gdp_pcap,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$NY.GDP.PCAP.PP.CD %in% NA)
    for (na_index in na_indices)
      tmp$NY.GDP.PCAP.PP.CD[na_index] <- tmp$NY.GDP.PCAP.PP.CD[na_index - 1]
    
    gdp_pcap$NY.GDP.PCAP.PP.CD[tmp_idx1:tmp_idx2] <- tmp$NY.GDP.PCAP.PP.CD
    print("Values after imputation: ")
    print(signif(gdp_pcap$NY.GDP.PCAP.PP.CD[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}

```
# Get the unemployment at percentage of total labour force
```{r}

# ========================================================================
# Get the unemployment at percentage of total labour force
# ========================================================================
unemployment <-  WDI(indicator = indicator_unemployment_total,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(unemployment$SL.UEM.TOTL.NE.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(unemployment$SL.UEM.TOTL.NE.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_unemployment_total,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.UEM.TOTL.NE.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.UEM.TOTL.NE.ZS[na_index] <- tmp$SL.UEM.TOTL.NE.ZS[na_index - 1]
    
    unemployment$SL.UEM.TOTL.NE.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.UEM.TOTL.NE.ZS
    print("Values afteriImputation: ")
    print(signif(unemployment$SL.UEM.TOTL.NE.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}

```
# Get the unemployment at percentage of total labour force for youths (15-24)
```{r}
# ========================================================================
# Get the unemployment at percentage of total labour force for youths (15-24)
# ========================================================================
unemployment_youth <-  WDI(indicator = indicator_unemployment_youth,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(unemployment_youth$SL.UEM.1524.NE.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(unemployment_youth$SL.UEM.1524.NE.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_unemployment_youth,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.UEM.1524.NE.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.UEM.1524.NE.ZS[na_index] <- tmp$SL.UEM.1524.NE.ZS[na_index - 1]
    
    unemployment_youth$SL.UEM.1524.NE.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.UEM.1524.NE.ZS
    print("Values afteriImputation: ")
    print(signif(unemployment_youth$SL.UEM.1524.NE.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}


```
# Get the unemployment at percentage of total labour force for males
```{r}
# ========================================================================
# Get the unemployment at percentage of total labour force for males
# ========================================================================
unemployment_male <-  WDI(indicator = indicator_unemployment_male,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(unemployment_male$SL.UEM.TOTL.MA.NE.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(unemployment_male$SL.UEM.TOTL.MA.NE.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_unemployment_male,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.UEM.TOTL.MA.NE.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.UEM.TOTL.MA.NE.ZS[na_index] <- tmp$SL.UEM.TOTL.MA.NE.ZS[na_index - 1]
    
    unemployment_male$SL.UEM.TOTL.MA.NE.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.UEM.TOTL.MA.NE.ZS
    print("Values afteriImputation: ")
    print(signif(unemployment_male$SL.UEM.TOTL.MA.NE.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}


```
# Get the unemployment at percentage of total labour force for females
```{r}
# ========================================================================
# Get the unemployment at percentage of total labour force for females
# ========================================================================
unemployment_female <-  WDI(indicator = indicator_unemployment_female,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(unemployment_female$SL.UEM.TOTL.FE.NE.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(unemployment_female$SL.UEM.TOTL.FE.NE.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_unemployment_female,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.UEM.TOTL.FE.NE.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.UEM.TOTL.FE.NE.ZS[na_index] <- tmp$SL.UEM.TOTL.FE.NE.ZS[na_index - 1]
    
    unemployment_female$SL.UEM.TOTL.FE.NE.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.UEM.TOTL.FE.NE.ZS
    print("Values afteriImputation: ")
    print(signif(unemployment_female$SL.UEM.TOTL.FE.NE.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}


```
# Get the employment at percentage of total labour force in agriculture
```{r}
# ========================================================================
# Get the employment at percentage of total labour force in agriculture
# ========================================================================
employment_agr <-  WDI(indicator = indicator_employment_agr,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(employment_agr$SL.AGR.EMPL.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(employment_agr$SL.AGR.EMPL.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_employment_agr,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.AGR.EMPL.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.AGR.EMPL.ZS[na_index] <- tmp$SL.AGR.EMPL.ZS[na_index - 1]
    
    employment_agr$SL.AGR.EMPL.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.AGR.EMPL.ZS
    print("Values afteriImputation: ")
    print(signif(employment_agr$SL.AGR.EMPL.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}


```
# Get the employment at percentage of total labour force in industry
```{r}
# ========================================================================
# Get the unemployment at percentage of total labour force for youths (15-24)
# ========================================================================
employment_industry <-  WDI(indicator = indicator_employment_industry,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(employment_industry$SL.IND.EMPL.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(employment_industry$SL.IND.EMPL.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_employment_industry,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.IND.EMPL.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.IND.EMPL.ZS[na_index] <- tmp$SL.IND.EMPL.ZS[na_index - 1]
    
    employment_industry$SL.IND.EMPL.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.IND.EMPL.ZS
    print("Values afteriImputation: ")
    print(signif(employment_industry$SL.IND.EMPL.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}


```
# Get the employment at percentage of total labour force in service
```{r}
# ========================================================================
# Get the unemployment at percentage of total labour force for youths (15-24)
# ========================================================================
employment_services <-  WDI(indicator = indicator_employment_services,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# ==========================================
# Impute missing values
# ==========================================
country_index <- 1
for (country in countries)
{
  tmp_idx1 <- (country_index-1)*num_years+1
  tmp_idx2 <- country_index*num_years
  num_na <- length(which(employment_services$SL.SRV.EMPL.ZS[tmp_idx1:tmp_idx2] %in% NA))
  
  # For this country, replace the NAs with the values of nearby years
  if (num_na > 0)
  {
    print(paste("Number of data points unavailable for ", countries[country_index], ": ", num_na, sep=''))
    print("Imputing missing values... ")
    print("Values before imputation: ")
    print(signif(employment_services$SL.SRV.EMPL.ZS[tmp_idx1:tmp_idx2],2))
    
    tmp <- WDI(indicator = indicator_employment_services,
               country = country,
               start = start_year,
               end = end_year)
    
    # set the value of the unavailable data point to the value of the next year.
    # this Works for now, as the data is available for the latest year for all countries.
    na_indices <- which(tmp$SL.SRV.EMPL.ZS %in% NA)
    for (na_index in na_indices)
      tmp$SL.SRV.EMPL.ZS[na_index] <- tmp$SL.SRV.EMPL.ZS[na_index - 1]
    
    employment_services$SL.SRV.EMPL.ZS[tmp_idx1:tmp_idx2] <- tmp$SL.SRV.EMPL.ZS
    print("Values afteriImputation: ")
    print(signif(employment_services$SL.SRV.EMPL.ZS[tmp_idx1:tmp_idx2],2))
  } 
  country_index <- country_index + 1
}


```
# Compute the linear regression between the unemployment and the GDP growth
```{r}

# ==========================================
# Compute the linear regression between the unemployment and the GDP growth
# ==========================================
onedf <- merge(gdp_pcap, unemployment)
onedf <- merge(merge(merge(merge(merge(merge(onedf, unemployment_youth), unemployment_female), unemployment_male), employment_agr), employment_industry), employment_services)

onedf <- onedf %>% 
  rename(
     unemployment_tot = SL.UEM.TOTL.NE.ZS,
     gdp = NY.GDP.PCAP.PP.CD,
     unemployment_youth = SL.UEM.1524.NE.ZS,
     unemployment_male = SL.UEM.TOTL.MA.NE.ZS,
     unemployment_female = SL.UEM.TOTL.FE.NE.ZS,
     employment_agr = SL.AGR.EMPL.ZS,
     employment_industry = SL.IND.EMPL.ZS,
     employment_services = SL.SRV.EMPL.ZS
    )

onedf_filt <- filter(onedf, year>=2015)

correlation_filt <- cor(onedf_filt$unemployment_tot, onedf_filt$gdp)



model <- lm(gdp~unemployment_tot, onedf)
model2 <-lm(gdp~unemployment_tot, onedf_filt)

plot(onedf$unemployment_tot, onedf$gdp, main=paste("All countries and years. Correlation: ", signif(correlation_filt, 3), sep=''), xlab="Unemployment %", ylab="GDP per capita PPP")

abline(model$coefficients[1], model$coefficients[2], col="red")
abline(model2$coefficients[1], model2$coefficients[2], col="blue")




```
# Mediation analysis (GDP, unemp_youth, empl_agr)
```{r}

# ==========================================
# Mediation 
# ==========================================
dep_var <- onedf_filt$gdp
indep_var <- onedf_filt$unemployment_youth
indep_var_fem <- onedf_filt$unemployment_female
mediator <- onedf_filt$employment_agr

df_mediation <- data.frame(indep_var,mediator,dep_var)
df_mediation_fem <- data.frame(indep_var_fem,mediator,dep_var)


fit.totaleffect=lm(dep_var~indep_var, df_mediation)
summary(fit.totaleffect)

fit.totaleffect_fem=lm(dep_var~indep_var_fem, df_mediation_fem)
summary(fit.totaleffect_fem)

fit.mediator=lm(mediator~indep_var,df_mediation)
summary(fit.mediator)

fit.mediator_fem=lm(mediator~indep_var_fem,df_mediation_fem)
summary(fit.mediator_fem)

fit.dv=lm(dep_var~indep_var+mediator,df_mediation)
summary(fit.dv)

fit.dv_fem=lm(dep_var~indep_var_fem+mediator,df_mediation_fem)
summary(fit.dv_fem)

results = mediate(fit.mediator, fit.dv, treat='indep_var', mediator='mediator', boot=T)
summary(results)

results_fem = mediate(fit.mediator_fem, fit.dv_fem, treat='indep_var_fem', mediator='mediator', boot=T)
summary(results_fem)

```
# Mediation analysis (GDP, unemp_youth, empl_ind)
```{r}

# ==========================================
# Mediation 
# ==========================================
dep_var <- onedf_filt$gdp
indep_var <- onedf_filt$unemployment_youth
indep_var_fem <- onedf_filt$unemployment_female
mediator <- onedf_filt$employment_industry

df_mediation <- data.frame(indep_var,mediator,dep_var)
df_mediation_fem <- data.frame(indep_var_fem,mediator,dep_var)


fit.totaleffect=lm(dep_var~indep_var, df_mediation)
summary(fit.totaleffect)

fit.totaleffect_fem=lm(dep_var~indep_var_fem, df_mediation_fem)
summary(fit.totaleffect_fem)

fit.mediator=lm(mediator~indep_var,df_mediation)
summary(fit.mediator)

fit.mediator_fem=lm(mediator~indep_var_fem,df_mediation_fem)
summary(fit.mediator_fem)

fit.dv=lm(dep_var~indep_var+mediator,df_mediation)
summary(fit.dv)

fit.dv_fem=lm(dep_var~indep_var_fem+mediator,df_mediation_fem)
summary(fit.dv_fem)

results = mediate(fit.mediator, fit.dv, treat='indep_var', mediator='mediator', boot=T)
summary(results)

results_fem = mediate(fit.mediator_fem, fit.dv_fem, treat='indep_var_fem', mediator='mediator', boot=T)
summary(results_fem)

```


# Mediation analysis (GDP, unemp_youth, empl_services)
```{r}

# ==========================================
# Mediation 
# ==========================================
dep_var <- onedf_filt$gdp
indep_var <- onedf_filt$unemployment_youth
indep_var_fem <- onedf_filt$unemployment_female
mediator <- onedf_filt$employment_services

df_mediation <- data.frame(indep_var,mediator,dep_var)
df_mediation_fem <- data.frame(indep_var_fem,mediator,dep_var)


fit.totaleffect=lm(dep_var~indep_var, df_mediation)
summary(fit.totaleffect)

fit.totaleffect_fem=lm(dep_var~indep_var_fem, df_mediation_fem)
summary(fit.totaleffect_fem)

fit.mediator=lm(mediator~indep_var,df_mediation)
summary(fit.mediator)

fit.mediator_fem=lm(mediator~indep_var_fem,df_mediation_fem)
summary(fit.mediator_fem)

fit.dv=lm(dep_var~indep_var+mediator,df_mediation)
summary(fit.dv)

fit.dv_fem=lm(dep_var~indep_var_fem+mediator,df_mediation_fem)
summary(fit.dv_fem)

results = mediate(fit.mediator, fit.dv, treat='indep_var', mediator='mediator', boot=T)
summary(results)

results_fem = mediate(fit.mediator_fem, fit.dv_fem, treat='indep_var_fem', mediator='mediator', boot=T)
summary(results_fem)

```
# Regression diagnostics
```{r}
# mean of residuals should be close to 0 (OK)
print(mean(residuals(model)))

#A common assumption is that residuals are normally distributed (NOT GAUSSIAN)
hist(residuals(model))

# Other assumptions are that residuals are uncorrelated with predicted values (OK)
cor(residuals(model), predict(model))

# variance of residuals is constant across the predicted value range ()
plot(predict(model), residuals(model))
```
# Bootstrapping to obtain an uncertainty on the correlation coefficient
```{r}
# ========================================================================
# Bootstrapping to obtain an uncertainty on the correlation coefficient
# ========================================================================
# obtain M bootstrap samples and calculate the correlation coefficient every time
M <- 10000
corr_gdp_unemployment_bootstrap <- numeric(M)
for(i in 1:M)
{
  sampling_indices <- sample(seq(1, length(unemployment$SL.UEM.TOTL.NE.ZS), by=1), size=num_datapoints, replace=TRUE)

  corr_gdp_unemployment_bootstrap[i] <- cor(unemployment$SL.UEM.TOTL.NE.ZS[sampling_indices],
                                            gdp_pcap$NY.GDP.PCAP.PP.CD[sampling_indices])
}

bt_mean <- signif(mean(corr_gdp_unemployment_bootstrap), 3)
bt_std <- signif(sd(corr_gdp_unemployment_bootstrap), 3)
bt_perc97 <- signif(quantile(corr_gdp_unemployment_bootstrap, probs=c(0.975)), 3)
bt_perc2 <- signif(quantile(corr_gdp_unemployment_bootstrap, probs=c(0.025)), 3)

hist(corr_gdp_unemployment_bootstrap,
     main=paste("Bootstrapped values of the correlation coefficient: mean", bt_mean, ", std.dev.: ", bt_std, sep=''),
     sub = "Red line shows the measured value.",
     xlab="Correlation (GDP, Unemployment)")
abline(v=corr_gdp_unemployment, col="red")

print(paste("The measured coefficient is ", signif(corr_gdp_unemployment, 3), sep=''))
print(paste("And the mean of the bootstrapped coefficient is ", bt_mean, sep=''))
print("Thus, the measurement is unbiased but there is quite a variance in the results:")
print(paste("The standard deviation is ", bt_std, sep=''))
paste("The 95% density interval goes from ", bt_perc97, " to ", bt_perc2, sep='')
print("Thus, the real correlation coefficient value for a larger sample could vary quite a bit.")

```
# Permutation test to compute the statistical significance of the correlation
```{r}

# ========================================================================
# Permutation test to compute the statistical significance of the correlation
# ========================================================================
# repeat shuffling for N times
N <- 10000 
# vector with the results of the test statistic under each permutation
corr_gdp_unemployment_permutation_test <- numeric(length = N) 
for(i in 1:N)
{
  unemployment_shufled <- unemployment[sample(nrow(unemployment)),]
  corr_gdp_unemployment_permutation_test[i] <- cor(unemployment_shufled$SL.UEM.TOTL.NE.ZS,
                                                   gdp_pcap$NY.GDP.PCAP.PP.CD)
}

# ==========================================
# Computing the p-value of the permutation test
# A nice explanation of permutation test can be read here: https://www.jwilber.me/permutationtest/
# ==========================================
p_value_Cor <- (sum(corr_gdp_unemployment_permutation_test<=corr_gdp_unemployment)+1)/length(corr_gdp_unemployment_permutation_test)
print(paste("p-value: ", signif(p_value_Cor, 3), sep=''))
print("As the p-value is smaller than 0.05, we can say that the observed correlation is statistically significant.")

```
# Plotting the histogram of the computed correlation coefficients.
```{r}
# ==========================================
# Plotting the histogram of the computed correlation coefficients.
# Showing as a red line, the correlation coefficient between the unshuffled variables.
# ==========================================
hist(corr_gdp_unemployment_permutation_test,
     xlim=range(c(corr_gdp_unemployment_permutation_test, corr_gdp_unemployment)),
     main=paste("Permutation test. P-value: ", signif(p_value_Cor, 3), sep=''),
     sub = "Red line shows the measured value.",
     xlab="Correlation (GDP, Unemployment)")
abline(v=corr_gdp_unemployment, col="red")


```



# ========================================================================
# Repeat the analysis for 
#   1. GDP growth vs Youth unemployment
#   2. GDP growth vs Male unemployment
#   3. GDP growth vs Female unemployment
#   4. GDP growth vs % of employment in industry sector 1
#   5. GDP growth vs % of employment in industry sector 2
# ========================================================================

# ========================================================================
# Other available indicators related to employment
# ========================================================================
# Some indicators are available in two formats: 1. national estimate and 2. modeled ILO estimate
# ========================================================================
# Unemployment, total (% of total labor force) (national estimate)(SL.UEM.TOTL.NE.ZS)
# Unemployment, total (% of total labor force) (modeled ILO estimate)(SL.UEM.TOTL.ZS)
# ===================
# Unemployment, youth total (% of total labor force ages 15-24) (national estimate)(SL.UEM.1524.NE.ZS)
# Unemployment, youth total (% of total labor force ages 15-24) (modeled ILO estimate)(SL.UEM.1524.ZS)
# ===================
# Unemployment, male (% of male labor force) (national estimate)(SL.UEM.TOTL.MA.NE.ZS)
# Unemployment, male (% of male labor force) (modeled ILO estimate)(SL.UEM.TOTL.MA.ZS)
# ===================
# Unemployment, female (% of female labor force) (national estimate)(SL.UEM.TOTL.FE.NE.ZS)
# Unemployment, female (% of female labor force) (modeled ILO estimate)(SL.UEM.TOTL.FE.ZS)
# ===================
# Employment in agriculture (% of total employment) (modeled ILO estimate) (SL.AGR.EMPL.ZS)
# The agriculture sector consists of activities in agriculture, hunting, forestry and fishing.
# ===================
# Employment in industry (% of total employment) (modeled ILO estimate) (SL.IND.EMPL.ZS)
# The industry sector consists of mining and quarrying, manufacturing, construction, and public utilities (electricity, gas, and water)
# ===================
# Employment in services (% of total employment) (SL.SRV.EMPL.ZS)
# The services sector consists of wholesale and retail trade and restaurants and hotels;
# transport, storage, and communications; financing, insurance, real estate, and business services; and community, social, and personal services
# ===================

