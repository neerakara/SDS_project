---
title: "LinkedIN_Analysis"
author: "Giorgio Cristiano"
date: "4/1/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Before beginning we install the needed packages

```{r install, echo = FALSE}
# install.packages("WDI")
# install.packages("dplyr")
# install.packages("tidyverse")
# install.packages("broom")
# install.packages("kableExtra")

library(WDI)
library(dplyr)
library(tidyverse)
library(broom)
library(boot)
library(kableExtra)
```


As a next step, we would like to use the LinkedIN data to investigate how migration is impacting the growth of a country. To do so we are going to use the data provided by a collaboration between World bank and LinkedIN. We can download the needed data from the website of the collaboration mentioned above:

```{r}
download.file("https://development-data-hub-s3-public.s3.amazonaws.com/ddhfiles/1202896/country_migration_public.csv", destfile = "CountryMigration.csv")

download.file("https://development-data-hub-s3-public.s3.amazonaws.com/ddhfiles/1202896/industry_migration_public.csv", destfile = "IndustryMigration.csv")

```

Now, we will need to process this data. As a first step we need to filter out only the data relative to countries whose WB Region is marked as "Europe and Centra Asia".

```{r}
countrydf_raw <- read.csv("CountryMigration.csv", header = T, sep = ",")
industrydf_raw <- read.csv("IndustryMigration.csv", header = T, sep = ",")
skilldf_raw <- read.csv("SkillMigration.csv", header = T, sep = ",")

countrydf <-countrydf_raw %>%
  filter(base_country_wb_region == "Europe & Central Asia") %>%
    filter(target_country_wb_region == "Europe & Central Asia")

industrydf <-industrydf_raw %>%
  filter(wb_region == "Europe & Central Asia")

skilldf <-skilldf_raw %>%
  filter(wb_region == "Europe & Central Asia")
```

While to get data on the countries GDP (normalized per capita), GDP growth and unemployment, we are going to use the WDI API interface, as from the following code snippet. To be consistent with the data provided by LinkedIN we are going to fetch the data between 2015 and 2019.

```{r WDIdata}
WDIdf <- WDI(indicator=c("NY.GDP.PCAP.PP.CD","NY.GDP.MKTP.KD.ZG", "SL.UEM.TOTL.NE.ZS"), country ="all", start = 2015, end = 2019, extra = F) %>% 
  select(country, year, NY.GDP.PCAP.PP.CD, NY.GDP.MKTP.KD.ZG, SL.UEM.TOTL.NE.ZS) %>% 
  rename(GDPpc = NY.GDP.PCAP.PP.CD,
         GDPgrowth = NY.GDP.MKTP.KD.ZG,
         unemploymentRate = SL.UEM.TOTL.NE.ZS)
```

Now that we have the data that we need we can merge it in a single database that shows the migration flux among European countries, and GDPpc, GDP growth, and unemployment for both the source and destination countries. To better understand how to use this dataframe, Table \@ref(tab:migrationFlux) shows the first 10 rows. We can see that each row contains information about a specific year, about the migration flux between a base and a target country. The migration flux is normalized according to the number of LinkedIN users in the base country. This number is positive when more people are arriving from, than leaving to the target country, and negative when the opposite happens.

```{r migrationFlux, echo=FALSE}
countrydf_merged <- countrydf %>%
  pivot_longer(cols = starts_with("net_per_10K_"),
               names_to = "year",
               names_prefix = "net_per_10K_",
               names_transform = list(year = as.integer),
               values_to = "net_per_10K",
               values_transform = list(net_per_10K = as.double)) %>%
  inner_join(WDIdf,  by = c("base_country_name" = "country", "year")) %>%
  inner_join(WDIdf, by = c("target_country_name" = "country", "year")) %>%
  rename(base_country_GDPpc = GDPpc.x, 
         target_country_GDPpc = GDPpc.y,
         base_country_GDPgrowth = GDPgrowth.x,
         target_country_GDPgrowth = GDPgrowth.y,
         base_country_unemploymentRate = unemploymentRate.x,
         target_country_unemploymentRate = unemploymentRate.y,
         migrationFlux_per10k = net_per_10K) %>% 
  select(year, base_country_code, base_country_name, 
         base_country_GDPpc, base_country_GDPgrowth, base_country_unemploymentRate,
         target_country_code, target_country_name,
         target_country_GDPpc, target_country_GDPgrowth, target_country_unemploymentRate,
         migrationFlux_per10k)
  
countrydf_merged %>%
  head(n = 10) %>% 
  kable(booktabs = T,
               caption = "First ten rows of the migration flux database.",
               label = "{tab:migrationFlux}")  %>% 
  kable_minimal()
```

Now that we have created the dataframe, we can start to investigate the relationship between the migration to a country and its wealth. As a first step we are going to plot a country's migration flux as a function of its GDP, grouped by year.

```{r migration_peryear, fig.height=7, fig.width=9.5, fig.show="hold", out.width="50%", echo = FALSE, warning=FALSE, message=FALSE, fig.cap = "Relation between net flux migration of country X expressed as unit per 10k linkedIN users of that country and the country's GDP per capita. The data are grouped by year, and interpolated by means of linear regression. \\label{fig:migration_peryear}"}
  
countrydf_tot <- countrydf_merged %>%
  group_by(base_country_code, base_country_name, year, base_country_GDPpc) %>% 
  summarise(totalflux = sum(migrationFlux_per10k))

model_list <- lapply(2015:2019, function(y){
  countrydf_tot %>% 
    filter(year == y) %>% 
    lm(totalflux ~ log(base_country_GDPpc), data = .) %>% 
    summary %>% 
    coefficients %>% 
    as.data.frame() %>% 
    select(Estimate, 
           "Std. Error") %>% 
    mutate(year = y) %>% 
    rename(stderr = "Std. Error") %>% 
    tail(1)
})

countrydf_tot %>% 
  mutate(year = as.character(year)) %>% 
  ggplot(aes(x = log(base_country_GDPpc), y = totalflux, color = year)) + 
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  theme_bw()

do.call("rbind", model_list) %>% 
  ggplot(aes(x = year, y = Estimate)) +
  geom_segment(aes(x = year, xend = year, y = (Estimate - stderr), 
                   yend = (Estimate + stderr)), 
               color = "darkgray", size = 1.5, alpha = 1) + 
  geom_point(size = 4, color = "#F55D5D") +
  theme_bw()

```
