---
title: "SDS Project "
author: "G. Cristiano, R. Incandela, N. Karani"
date: "3/25/2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
  word_document: default
sansfont: Calibri Light
---
\fontsize{11}{16}
\selectfont

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r install, echo = FALSE, message = FALSE, warning = FALSE}
# Install required modules
# If not done yet, install the required modules, and load them.
# In particular, we need the WDI package. It downloads the requested data by using the World Bank's API, parses the resulting XML file, and formats it in long country-year format.
if(!require(WDI)){
  install.packages("WDI")
  library(WDI)
}

#install.packages("ggplot2")
library(ggplot2)

#install.packages("kableExtra")
library(kableExtra)
#install.packages("mediation")
#install.packages("tidyverse")

library(mediation)
library(tidyverse)
library(dplyr)
library(broom)
library(boot)
```

## List of countries of interest
We consider all European countries: Austria, Belgium, Bulgaria, Switzerland, Cyprus, Czech Republic, Germany, Denmark, Spain, Estonia, Finland, France, United Kingdom, Greece, Croatia, Hungary, Iceland, Italy, Lithuania, Luxembourg, Latvia, Malta, Netherlands, Norway, Poland, Portugal, Romania, Slovakia, Slovenia and Sweden. The ISO country codes can be searched from https://www.iban.com/country-codes.

```{r, echo=FALSE, message = FALSE, warning = FALSE}
countries <- c("AT", # Austria
               "BE", # Belgium
               "BG", # Bulgaria
               "CH", # Switzerland
               "CY", # Cyprus
               "CZ", # Czech Republic
               "DE", # Germany
               "DK", # Denmark
               "ES", # Spain
               "EE", # Estonia
               "FI", # Finland
               "FR", # France
               "GB", # United Kingdom
               "GR", # Greece
               "HR", # Croatia
               "HU", # Hungary
               "IE", # Ireland
               "IT", # Italy
               "LT", # Lithuania
               "LU", # Luxembourg
               "LV", # Latvia
               "MT", # Malta
               "NL", # Netherlands 
               "PL", # Poland
               "PT", # Portugal
               "RO", # Romania
               "SK", # Slovakia
               "SI", # Slovenia
               "SE"  # Sweden
               )

# To do the analysis for a subset of the countries, edit and uncomment the following line 
# countries <- c("NL")
num_countries <- length(countries)
```

## Time period of interest
In order to keep the time period consistent between the world bank and the LinkedIn data, we choose the time period of interest from 2015 to 2019.

```{r, echo=FALSE, message = FALSE, warning = FALSE}
start_year <- 2015
end_year <- 2019
num_years <- end_year - start_year + 1
num_datapoints <- num_countries * num_years
```

## Economic indicators of interest
For these indicators, we extract the data from the world bank interface. The entire list of indicators can be seen here: https://databank.worldbank.org/source/world-development-indicators.

First, we need the GDP per capita. This is the main variable of interest. For the analyses, we consider this as the dependent variable, and seek to understand the effect of various unemployment related parameters on the GDP per capita. There are several indicators of GDP per capital: constant 2010 US dollars, current US dollars, constant LCU, current LCU, etc. We use the GDP per capita in constant 2010 US dollars for our analysis.

```{r, echo=FALSE, message = FALSE, warning = FALSE}
indicator_gdp_growth <- "NY.GDP.MKTP.KD.ZG"
indicator_gdp_per_capita <- "NY.GDP.PCAP.KD" # constant 2010 US$
# indicator_gdp_per_capita <- "NY.GDP.PCAP.CD" # GDP per capita (current US$)
# indicator_gdp_per_capita <- "NY.GDP.PCAP.KN" # GDP per capita (constant LCU)
# indicator_gdp_per_capita <- "NY.GDP.PCAP.CN" # GDP per capita (current LCU)
```

Among the unemployment indicators, we consider (i) the total unemployment percentage, (ii) the unemployment percentage in youths (ages 15-24), (iii) the unemployment percentage among males, and (iv) the unemployment percentage among females. In the world bank interface, for all these indicators, we have two estimates: (i) a national estimate and (ii) a modeled ILO estimate. For our analysis, we consider the national estimate.

```{r, echo=FALSE, message = FALSE, warning = FALSE}
indicator_unemployment_total <- "SL.UEM.TOTL.NE.ZS" # Unemployment, total (% of total labor force) (national estimate)
indicator_unemployment_youth <- "SL.UEM.1524.NE.ZS" # Unemployment, youth total (% of total labor force ages 15-24) (national estimate)
indicator_unemployment_male <- "SL.UEM.TOTL.MA.NE.ZS" # Unemployment, male (% of male labor force) (national estimate)
indicator_unemployment_female <- "SL.UEM.TOTL.FE.NE.ZS" # Unemployment, female (% of female labor force) (national estimate)
```

Finally, we consider the division of the total employment in different industry sectors: namely (i) agriculture (consisting of activities in agriculture, hunting, forestry and fishing), (ii) industry (consisting of mining and quarrying, manufacturing, construction, and public utilities (electricity, gas, and water) and (iii) services (consisting of wholesale and retail trade and restaurants and hotels; transport, storage, and communications; financing, insurance, real estate, and business services; and community, social, and personal services). For these indicators, only one estimate (the modeled ILO estimate) is available, and we use the same.

```{r, echo=FALSE, message = FALSE, warning = FALSE}
indicator_employment_agriculture <- "SL.AGR.EMPL.ZS" # Employment in agriculture (% of total employment) ()
indicator_employment_industry <- "SL.IND.EMPL.ZS" # Employment in industry (% of total employment) (modeled ILO estimate)
indicator_employment_services <- "SL.SRV.EMPL.ZS" # Employment in services (% of total employment)
```

## Correlation between total unemployment and GDP per capita (2015 - 2019)

```{r, echo=FALSE, message = FALSE, warning = FALSE}
# load the GDP per capita
gdp_per_capita <- WDI(indicator = indicator_gdp_per_capita,
                      country = countries,
                      start = start_year,
                      end = end_year)

# load the total unemployment
unemployment <-  WDI(indicator = indicator_unemployment_total,
                     country = countries,
                     start = start_year,
                     end = end_year)
# The data is read from end_year to start_year for country[1], followed by end_year to start_year for country[2], and so on..
# Also, the countries are arranged in  the alphabetical order of their ISO codes! 
# For now, I have set ordered the values in the vector countries such that it remains the same after being read by WDI.

# Compute the correlation between the total unemployment and the GDP per capita
corr_gdp_unemployment <- cor(unemployment[,3], gdp_per_capita[,3])
corr_gdp_unemployment <- signif(corr_gdp_unemployment, 3)
```

The Pearson correlation coefficient between the total unemployment rate and the per capita GDP between 2015 and 2019 in European countries is `r corr_gdp_unemployment`.

```{r, fig.width = 5, fig.height = 5, echo=FALSE, message = FALSE, warning = FALSE}
# Plot the GDP per capita vs the Unemployment rate  (for all countries and all years together)
plot(unemployment[,3],
     gdp_per_capita[,3],
     main="Europe, 2015-2019",
     xlab="Total unemployment %",
     ylab="GDP per capita (constant 2010 USD)",
     cex=0.5)
```

```{r permutation, echo=FALSE, message = FALSE, warning = FALSE}
# Permutation test to compute the statistical significance of the correlation
# repeat shuffling for N times
N <- 10000 
# vector with the results of the test statistic under each permutation
corr_gdp_unemployment_permutation_test <- numeric(length = N) 
for(i in 1:N)
{
  unemployment_shufled <- unemployment[sample(nrow(unemployment)),]
  corr_gdp_unemployment_permutation_test[i] <- cor(unemployment_shufled[,3],
                                                   gdp_per_capita[,3])
}

# Computing the p-value of the permutation test
# A nice explanation of permutation test can be read here: https://www.jwilber.me/permutationtest/
# For testing the significance of a positive correlation, we need a >= in the formula below
# For testing the significance of a negative correlation, we need a <= in the formula below
p_value_Cor <- (sum(corr_gdp_unemployment_permutation_test<=corr_gdp_unemployment)+1)/length(corr_gdp_unemployment_permutation_test)
```

In order to check the statistical significance of the computed correlation, let's do a permutation analysis. Taking `r N` permutations, we find the p-value of the measured correlation to be `r p_value_Cor`. As the p-value is smaller than 0.05, the measured correlation is statistically significant.

```{r permutation_plot, echo=FALSE, fig.width = 5, fig.height = 5, message = FALSE, warning = FALSE}
# Plotting the histogram of the computed correlation coefficients.
# Showing as a red line, the correlation coefficient between the unshuffled variables.
hist(corr_gdp_unemployment_permutation_test,
     xlim=range(c(corr_gdp_unemployment_permutation_test, corr_gdp_unemployment)),
     main="Permutation test",
     xlab="Correlation coefficient",
     cex=0.5)
abline(v=corr_gdp_unemployment, col="red")
```

```{r bootstrap, echo=FALSE, message = FALSE, warning = FALSE}
# Bootstrapping to obtain an uncertainty on the correlation coefficient
# obtain M bootstrap samples and calculate the correlation coefficient every time
M <- 10000
corr_gdp_unemployment_bootstrap <- numeric(M)
for(i in 1:M)
{
  sampling_indices <- sample(seq(1, length(unemployment[,3]), by=1), size=num_datapoints, replace=TRUE)
  corr_gdp_unemployment_bootstrap[i] <- cor(unemployment[,3][sampling_indices], gdp_per_capita[,3][sampling_indices])
}

bt_mean <- signif(mean(corr_gdp_unemployment_bootstrap), 3)
bt_std <- signif(sd(corr_gdp_unemployment_bootstrap), 3)
bt_perc97 <- signif(quantile(corr_gdp_unemployment_bootstrap, probs=c(0.975)), 3)
bt_perc2 <- signif(quantile(corr_gdp_unemployment_bootstrap, probs=c(0.025)), 3)
```

Further, let's do a bootstrap analysis to quantify the uncertainty in the measured correlation value. Repeating the bootstrap analysis `r M` times, we find the mean correlation to be `r bt_mean`, with a standard deviation of `r bt_std`. Thus, although the measured coefficient is unbiased, there seems to relatively high uncertainty in the measurement. This shows the unreliability of the measured correlation, and indicates that the real correlation value for a larger data-set may be remarkably different.

```{r, fig.width = 5, fig.height = 5, echo=FALSE, message = FALSE, warning = FALSE}
hist(corr_gdp_unemployment_bootstrap,
     main="Bootstrapping analysis",
     xlab="Correlation coefficient",
     cex=0.5)
abline(v=corr_gdp_unemployment, col="red")

# print(paste("The measured coefficient is ", signif(corr_gdp_unemployment, 3), sep=''))
# print(paste("And the mean of the bootstrapped coefficient is ", bt_mean, sep=''))
# print(paste("The standard deviation is ", bt_std, sep=''))
# paste("The 95% density interval goes from ", bt_perc97, " to ", bt_perc2, sep='')
```

## Yearwise analysis (2005 - 2019)
The substantial uncertainty in the measured correlation could be due to multiple reasons. It may indicate that the relationship between the GDP per capita and the total unemployment is complicated, and perhaps dependent on several other variables. Further, the cumulative analysis over the 5 year time period (2015 - 2019) may be further complicating the relationship by introducing additional variations that may have occurred in different countries in different years within the considered time period. In order to alleviate this complication, we study the relationship between the GDP per capita and the total unemployment for each year separately. As there is no dependency of this yearwise analysis on the LinkedIN analysis, and to benefit from the additional data available via the WDI interface, we include an extended time period: from 2005 to 2019.

```{r correlation_one_year, echo=FALSE, cache=TRUE, message = FALSE, warning = FALSE}
years = c()
coefs = c()
btmeans = c()
btstd = c()
pvalues = c()

print("Year | Correlation | BT mean | BT std | p-value")

for (year in seq(from = 2005, to = 2019, by = 1))
{

  # load the GDP per capita
  gdp_per_capita <- WDI(indicator = indicator_gdp_per_capita,
                        country = countries,
                        start = year,
                        end = year)

  # load the total unemployment
  unemployment <-  WDI(indicator = indicator_unemployment_total,
                       country = countries,
                       start = year,
                       end = year)

  # Compute the correlation between the total unemployment and the GDP per capita
  corr_gdp_unemployment_this_year <- signif(cor(unemployment[,3], gdp_per_capita[,3]), 3)
  
  # permutation test for this year
  N <- 10000 
  # vector with the results of the test statistic under each permutation
  corr_gdp_unemployment_permutation_test <- numeric(length = N) 
  for(i in 1:N)
  {
    unemployment_shufled <- unemployment[sample(nrow(unemployment)),]
    corr_gdp_unemployment_permutation_test[i] <- cor(unemployment_shufled[,3],
                                                     gdp_per_capita[,3])
  }
  p_value_Cor <- (sum(corr_gdp_unemployment_permutation_test<=corr_gdp_unemployment_this_year)+1)/length(corr_gdp_unemployment_permutation_test)
  
  # bootstrap analysis for this year
  M <- 10000
  corr_gdp_unemployment_bootstrap <- numeric(M)
  for(i in 1:M)
  {
    sampling_indices <- sample(seq(1, length(unemployment[,3]), by=1), size=num_countries, replace=TRUE)
    corr_gdp_unemployment_bootstrap[i] <- cor(unemployment[,3][sampling_indices], gdp_per_capita[,3][sampling_indices])
  }
  bt_mean <- signif(mean(corr_gdp_unemployment_bootstrap), 3)
  bt_std <- signif(sd(corr_gdp_unemployment_bootstrap), 3)

  print(paste(year, corr_gdp_unemployment_this_year, bt_mean, bt_std, p_value_Cor))
  
  years <- append(years, year)
  coefs <- append(coefs, corr_gdp_unemployment_this_year)
  btmeans <- append(btmeans, bt_mean)
  btstd <- append(btstd, bt_std)
  pvalues <- append(pvalues, p_value_Cor)
  
}

qplot(years, coefs) + geom_errorbar(aes(x=years, ymin=coefs-btstd, ymax=coefs+btstd), width=0.25) + ggtitle("Longitudinal analysis") + xlab("Year") + ylab("Correlation coefficient")
```

We observe a clear trend in the yearwise analysis: the  correlation between the total unemployment and the GDP per capita becomes consistently weaker from 2010 to 2019. The error bars in the plot above indicate the standard deviation values computed via bootstrapping. Further, permutation testing shows that the correlation values before 2016 are statistically significant, while the ones from 2016 are not.

Based on this analysis, we conclude that there may be several time-dependent factors affecting the relationship between the GDP per capita and the total unemployment. A multivariate analysis including such additional factors is outside the scope of this project. Accordingly, we decide to focus on a single year for the further analysis. As the correlation is statistically significant before 2016, and we have LinkedIn data available from 2015 onwards, 2015 is the only year which matches both our analysis criteria. 

```{r, echo=FALSE, message = FALSE, warning = FALSE}
compute_correlation <- function(indc_gdp, indc_employ, countries, year)
{
  
  gdp_per_capita <- WDI(indicator = indc_gdp, country = countries, start = year, end = year) # load the GDP per capita
  unemployment <-  WDI(indicator = indc_employ, country = countries, start = year, end = year) # load the total unemployment
  corr <- signif(cor(unemployment[,3], gdp_per_capita[,3]), 3) # Compute correlation
  
  # Permutation test to compute the statistical significance of the correlation
  N <- 10000
  corr_perm_test <- numeric(length = N) 
  for(i in 1:N)
  {
    unemployment_shufled <- unemployment[sample(nrow(unemployment)),]
    corr_perm_test[i] <- cor(unemployment_shufled[,3], gdp_per_capita[,3])
  }
  p_value <- signif((sum(corr_perm_test<=corr)+1)/length(corr_perm_test), 3)
  
  # Bootstrapping to obtain an uncertainty on the correlation coefficient
  M <- 10000
  corr_bootstrap <- numeric(M)
  for(i in 1:M)
  {
    sampling_indices <- sample(seq(1, length(unemployment[,3]), by=1), size=num_datapoints, replace=TRUE)
    corr_bootstrap[i] <- cor(unemployment[,3][sampling_indices], gdp_per_capita[,3][sampling_indices])
  }
  bt_mean <- signif(mean(corr_bootstrap), 3)
  bt_std <- signif(sd(corr_bootstrap), 3)

  cor_list <- list("year" = year, "coef" = corr, "btmean" = bt_mean, "btstd" = bt_std, "p" = p_value)
  
  return(cor_list)
}
```

## Group Analysis (2015)
The table below shows the correlation values for different sub-groups in the population. It can be seen that the correlation values are quite similar for all the considered groups.

```{r group_analysis, echo=FALSE, message = FALSE, warning = FALSE}
cor_total <- compute_correlation(indicator_gdp_per_capita, indicator_unemployment_total, countries, 2015)
cor_youth <- compute_correlation(indicator_gdp_per_capita, indicator_unemployment_youth, countries, 2015)
cor_male <- compute_correlation(indicator_gdp_per_capita, indicator_unemployment_male, countries, 2015)
cor_female <- compute_correlation(indicator_gdp_per_capita, indicator_unemployment_female, countries, 2015)

group_coefs <- c(cor_total$coef, cor_youth$coef, cor_male$coef, cor_female$coef)
group_btmean <- c(cor_total$btmean, cor_youth$btmean, cor_male$btmean, cor_female$btmean)
group_btstd <- c(cor_total$btstd, cor_youth$btstd, cor_male$btstd, cor_female$btstd)
group_pvalues <- c(cor_total$p, cor_youth$p, cor_male$p, cor_female$p)
correlation_group_analysis <- data.frame(group_coefs, group_btmean, group_btstd, group_pvalues)

rownames(correlation_group_analysis) <- c("Total", "Youth", "Male", "Female")
kable(correlation_group_analysis,  col.names = c("Correlation",
                                                 "Bootstrapping mean",
                                                 "Bootstrapping std. dev.",
                                                 "P-value")) %>% kable_material(c("striped", "hover"))
```


## Mediation Analysis (2015)

# Dataframe merging

```{r mediation_analysis, echo=FALSE, message = FALSE, warning = FALSE}
# Dataframe merging
gdp_per_capita <- WDI(indicator = indicator_gdp_per_capita, 
                      country = countries, 
                      start = start_year, 
                      end = end_year)

unemployment <-  WDI(indicator = indicator_unemployment_total, 
                     country = countries, 
                     start = start_year, 
                     end = end_year) 

unemployment_youth <-  WDI(indicator = indicator_unemployment_youth,
                     country = countries,
                     start = start_year,
                     end = end_year)
unemployment_male <-  WDI(indicator = indicator_unemployment_male,
                     country = countries,
                     start = start_year,
                     end = end_year)
unemployment_female <-  WDI(indicator = indicator_unemployment_female,
                     country = countries,
                     start = start_year,
                     end = end_year)
employment_agr <-  WDI(indicator = indicator_employment_agriculture,
                     country = countries,
                     start = start_year,
                     end = end_year)
employment_industry <-  WDI(indicator = indicator_employment_industry,
                     country = countries,
                     start = start_year,
                     end = end_year)
employment_services <-  WDI(indicator = indicator_employment_services,
                     country = countries,
                     start = start_year,
                     end = end_year)



onedf <- merge(gdp_per_capita, unemployment)
onedf <- merge(merge(merge(merge(merge(merge(onedf, unemployment_youth), unemployment_female), unemployment_male), employment_agr), employment_industry), employment_services)

onedf <- onedf %>% 
  rename(
     unemployment = SL.UEM.TOTL.NE.ZS,
     gdp_per_capita = NY.GDP.PCAP.KD,
     unemployment_youth = SL.UEM.1524.NE.ZS,
     unemployment_male = SL.UEM.TOTL.MA.NE.ZS,
     unemployment_female = SL.UEM.TOTL.FE.NE.ZS,
     employment_agr = SL.AGR.EMPL.ZS,
     employment_industry = SL.IND.EMPL.ZS,
     employment_services = SL.SRV.EMPL.ZS
    )

onedf_filt <- filter(onedf, year==2015)
```

```{r mediation_agr, echo=FALSE, message = FALSE, warning = FALSE}
# Mediation analysis (GDP, unemp_youth, empl_agr)
agr_dep_var <- onedf_filt$gdp
agr_indep_var <- onedf_filt$employment_agr
agr_indep_var_fem <- onedf_filt$employment_agr
agr_mediator <- onedf_filt$unemployment_youth
agr_mediator_fem <- onedf_filt$unemployment_female

agr_df_mediation <- data.frame(agr_indep_var,agr_mediator,agr_dep_var)
agr_df_mediation_fem <- data.frame(agr_indep_var_fem,agr_mediator_fem,agr_dep_var)

agr.totaleffect=lm(agr_dep_var~agr_indep_var, agr_df_mediation)
#summary(agr.totaleffect)

agr.totaleffect_fem=lm(agr_dep_var~agr_indep_var_fem, agr_df_mediation_fem)
#summary(agr.totaleffect_fem)

agr.agr_mediator=lm(agr_mediator~agr_indep_var,agr_df_mediation)
#summary(agr.agr_mediator)

agr.agr_mediator_fem=lm(agr_mediator_fem~agr_indep_var_fem,agr_df_mediation_fem)
#summary(agr.agr_mediator_fem)

agr.dv=lm(agr_dep_var~agr_indep_var+agr_mediator,agr_df_mediation)
#summary(agr.dv)

agr.dv_fem=lm(agr_dep_var~agr_indep_var_fem+agr_mediator_fem,agr_df_mediation_fem)
#summary(agr.dv_fem)

agr_results = mediate(agr.agr_mediator, agr.dv, treat='agr_indep_var', mediator='agr_mediator', boot=T)
#summary(agr_results)

agr_results_fem = mediate(agr.agr_mediator_fem, agr.dv_fem, treat='agr_indep_var_fem', mediator='agr_mediator_fem', boot=T)
#summary(agr_results_fem)

plot(agr_indep_var, agr_dep_var, xlab="Employment in agriculture %", 
     ylab="GDP per capita (constant 2010 USD)", main="Scatter Plot of GDP per cap ~ Employment in agriculture", pch=19,
     col=c("blue"))

plot(agr_indep_var, agr_dep_var, xlab="Employment in agriculture %", 
     ylab="GDP per capita (constant 2010 USD)", main="Scatter Plot of GDP per cap ~ Employment in agriculture", pch=19,
     col=c("blue"))



agr_group_tot <- c(agr.totaleffect$coefficients[2],agr.totaleffect_fem$coefficients[2])
agr_group_tot_p <- c(summary(agr.totaleffect)$coefficients[2,4], summary(agr.totaleffect_fem)$coefficients[2,4])
agr_group_mediator <- c(agr.agr_mediator$coefficients[2],agr.agr_mediator_fem$coefficients[2])
agr_group_mediator_p <- c(summary(agr.agr_mediator)$coefficients[2,4], summary(agr.agr_mediator_fem)$coefficients[2,4])
agr_group_dv <- c(agr_results$d0, agr_results_fem$d0)
agr_group_dv_p <- c(agr_results$d0.p, agr_results_fem$d0.p)

agr_group_analysis <- data.frame(agr_group_tot,agr_group_tot_p, agr_group_mediator, agr_group_mediator_p, agr_group_dv, agr_group_dv_p)
rownames(agr_group_analysis) <- c("Youth", "Female")
kable(agr_group_analysis,  col.names = c("I->D",
                                         "p-value",
                                         "I->M",
                                         "p-value",
                                         "ACME",
                                         "p-value")) %>% kable_material(c("striped", "hover"))

```

# Mediation analysis (GDP, unemp_youth, empl_ind)

```{r mediation_ind, echo=FALSE, message = FALSE, warning = FALSE}
# Mediation analysis (GDP, unemp_youth, empl_ind)
# ==========================================
# Mediation 
# ==========================================
ind_dep_var <- onedf_filt$gdp
ind_indep_var <- onedf_filt$employment_industry
ind_indep_var_fem <- onedf_filt$employment_industry
ind_mediator <- onedf_filt$unemployment_youth
ind_mediator_fem <- onedf_filt$unemployment_female

ind_df_mediation <- data.frame(ind_indep_var,ind_mediator,ind_dep_var)
ind_df_mediation_fem <- data.frame(ind_indep_var_fem,ind_mediator_fem,ind_dep_var)

ind.totaleffect=lm(ind_dep_var~ind_indep_var, ind_df_mediation)
#summary(ind.totaleffect)

ind.totaleffect_fem=lm(ind_dep_var~ind_indep_var_fem, ind_df_mediation_fem)
#summary(ind.totaleffect_fem)

ind.ind_mediator=lm(ind_mediator~ind_indep_var,ind_df_mediation)
#summary(ind.ind_mediator)

ind.ind_mediator_fem=lm(ind_mediator_fem~ind_indep_var_fem,ind_df_mediation_fem)
#summary(ind.ind_mediator_fem)

ind.dv=lm(ind_dep_var~ind_indep_var+ind_mediator,ind_df_mediation)
#summary(ind.dv)

ind.dv_fem=lm(ind_dep_var~ind_indep_var_fem+ind_mediator_fem,ind_df_mediation_fem)
#summary(ind.dv_fem)

ind_results = mediate(ind.ind_mediator, ind.dv, treat='ind_indep_var', mediator='ind_mediator', boot=T)
#summary(ind_results)

ind_results_fem = mediate(ind.ind_mediator_fem, ind.dv_fem, treat='ind_indep_var_fem', mediator='ind_mediator_fem', boot=T)
#summary(ind_results_fem)



plot(ind_indep_var, ind_dep_var)

ind_group_tot <- c(ind.totaleffect$coefficients[2],ind.totaleffect_fem$coefficients[2])
ind_group_tot_p <- c(summary(ind.totaleffect)$coefficients[2,4], summary(ind.totaleffect_fem)$coefficients[2,4])
ind_group_mediator <- c(ind.ind_mediator$coefficients[2],ind.ind_mediator_fem$coefficients[2])
ind_group_mediator_p <- c(summary(ind.ind_mediator)$coefficients[2,4], summary(ind.ind_mediator_fem)$coefficients[2,4])
ind_group_dv <- c(ind_results$d0, ind_results_fem$d0)
ind_group_dv_p <- c(ind_results$d0.p, ind_results_fem$d0.p)

ind_group_analysis <- data.frame(ind_group_tot,ind_group_tot_p, ind_group_mediator, ind_group_mediator_p, ind_group_dv, ind_group_dv_p)
rownames(ind_group_analysis) <- c("Youth", "Female")
kable(ind_group_analysis,  col.names = c("I->D",
                                         "p-value",
                                         "I->M",
                                         "p-value",
                                         "ACME",
                                         "p-value")) %>% kable_material(c("striped", "hover"))


```

# Mediation analysis (GDP, unemp_youth, empl_services)

```{r mediation_ser, echo=FALSE, message = FALSE, warning = FALSE}
# Mediation analysis (GDP, unemp_youth, empl_services)
ser_dep_var <- onedf_filt$gdp
ser_indep_var <- onedf_filt$employment_services
ser_indep_var_fem <- onedf_filt$employment_services
ser_mediator <- onedf_filt$unemployment_youth
ser_mediator_fem <- onedf_filt$unemployment_female

ser_df_mediation <- data.frame(ser_indep_var,ser_mediator,ser_dep_var)
ser_df_mediation_fem <- data.frame(ser_indep_var_fem,ser_mediator_fem,ser_dep_var)

ser.totaleffect=lm(ser_dep_var~ser_indep_var, ser_df_mediation)
#summary(ser.totaleffect)

ser.totaleffect_fem=lm(ser_dep_var~ser_indep_var_fem, ser_df_mediation_fem)
#summary(ser.totaleffect_fem)

ser.ser_mediator=lm(ser_mediator~ser_indep_var,ser_df_mediation)
#summary(ser.ser_mediator)

ser.ser_mediator_fem=lm(ser_mediator_fem~ser_indep_var_fem,ser_df_mediation_fem)
#summary(ser.ser_mediator_fem)

ser.dv=lm(ser_dep_var~ser_indep_var+ser_mediator,ser_df_mediation)
#summary(ser.dv)

ser.dv_fem=lm(ser_dep_var~ser_indep_var_fem+ser_mediator_fem,ser_df_mediation_fem)
#summary(ser.dv_fem)

ser_results = mediate(ser.ser_mediator, ser.dv, treat='ser_indep_var', mediator='ser_mediator', boot=T)
#summary(ser_results)

ser_results_fem = mediate(ser.ser_mediator_fem, ser.dv_fem, treat='ser_indep_var_fem', mediator='ser_mediator_fem', boot=T)
#summary(ser_results_fem)



plot(ser_indep_var, ser_dep_var)


ser_group_tot <- c(ser.totaleffect$coefficients[2],ser.totaleffect_fem$coefficients[2])
ser_group_tot_p <- c(summary(ser.totaleffect)$coefficients[2,4], summary(ser.totaleffect_fem)$coefficients[2,4])
ser_group_mediator <- c(ser.ser_mediator$coefficients[2],ser.ser_mediator_fem$coefficients[2])
ser_group_mediator_p <- c(summary(ser.ser_mediator)$coefficients[2,4], summary(ser.ser_mediator_fem)$coefficients[2,4])
ser_group_dv <- c(ser_results$d0, ser_results_fem$d0)
ser_group_dv_p <- c(ser_results$d0.p, ser_results_fem$d0.p)

ser_group_analysis <- data.frame(ser_group_tot,ser_group_tot_p, ser_group_mediator, ser_group_mediator_p, ser_group_dv, ser_group_dv_p)
rownames(ser_group_analysis) <- c("Youth", "Female")
kable(ser_group_analysis,  col.names = c("I->D",
                                         "p-value",
                                         "I->M",
                                         "p-value",
                                         "ACME",
                                         "p-value")) %>% kable_material(c("striped", "hover"))

```


## Sector Analysis with WDI data (2015)
In the remaining part of the project, we consider the effect of different employment sectors on the GDP. The table below shows the correlation values for different employment sectors. It can be seen that employment in agriculture and industry is negatively correlated with GDP per capita, while employment in services is positively correlated with the GDP per capita.

```{r sector_analysis, echo=FALSE, message = FALSE, warning = FALSE}
cor_agri <- compute_correlation(indicator_gdp_per_capita, indicator_employment_agriculture, countries, 2015)
cor_indus <- compute_correlation(indicator_gdp_per_capita, indicator_employment_industry, countries, 2015)
cor_serv <- compute_correlation(indicator_gdp_per_capita, indicator_employment_services, countries, 2015)

sector_coefs <- c(cor_agri$coef, cor_indus$coef, cor_serv$coef)
sector_btmean <- c(cor_agri$btmean, cor_indus$btmean, cor_serv$btmean)
sector_btstd <- c(cor_agri$btstd, cor_indus$btstd, cor_serv$btstd)
sector_pvalues <- c(cor_agri$p, cor_indus$p, cor_serv$p)
correlation_sector_analysis <- data.frame(sector_coefs, sector_btmean, sector_btstd, sector_pvalues)

rownames(correlation_sector_analysis) <- c("Agriculture", "Industry", "Services")
kable(correlation_sector_analysis,  col.names = c("Correlation",
                                                 "Bootstrapping mean",
                                                 "Bootstrapping std. dev.",
                                                 "P-value")) %>% kable_material(c("striped", "hover"))

```

As a next step, we would like to use the LinkedIN data to investigate how migration is impacting the growth of a country. To do so we are going to use the data provided by a collaboration between World bank and LinkedIN [citation needed]. To be consistent in our analysis we will carry out this analysis filtering only the countries whose WB Region is marked as "Europe and Central Asia".

```{r, echo = FALSE}
download.file(
  "https://development-data-hub-s3-public.s3.amazonaws.com/ddhfiles/1202896/country_migration_public.csv",
  destfile = "CountryMigration.csv")

download.file(
  "https://development-data-hub-s3-public.s3.amazonaws.com/ddhfiles/1202896/industry_migration_public.csv",
  destfile = "IndustryMigration.csv")

```


```{r, echo = FALSE, warning=FALSE, message=FALSE,}
# ciao

countrydf_raw <- read.csv("CountryMigration.csv", header = T, sep = ",")
industrydf_raw <- read.csv("IndustryMigration.csv", header = T, sep = ",")

countrydf <-countrydf_raw %>%
  filter(base_country_wb_region == "Europe & Central Asia") %>%
    filter(target_country_wb_region == "Europe & Central Asia")

industrydf <-industrydf_raw %>%
  filter(wb_region == "Europe & Central Asia")

```

While to get data on the countries GDP (normalized per capita), and GDP growth we are going to use the WDI API interface [citation needed]. To be consistent with the data provided by LinkedIN we are going to fetch the data between 2015 and 2019.

```{r WDIdata, echo = FALSE}
WDIdf <- WDI(indicator=c("NY.GDP.PCAP.PP.CD","NY.GDP.MKTP.KD.ZG"),
             country ="all", start = 2015, end = 2019, extra = F) %>% 
  select(country, year, NY.GDP.PCAP.PP.CD, NY.GDP.MKTP.KD.ZG) %>% 
  rename(GDPpc = NY.GDP.PCAP.PP.CD,
         GDPgrowth = NY.GDP.MKTP.KD.ZG)
```

Now that we have the data that we need we can merge it in a single database that shows the migration flux among European countries, and GDPpc, GDP growth, and unemployment for both the source and destination countries. Each row contains information about a specific year, about the migration flux between a base and a target country. The migration flux is normalized according to the number of LinkedIN users in the base country. This number is positive when more people are arriving from, than leaving to the target country, and negative when the opposite happens.

```{r migrationFlux, echo=FALSE, message = FALSE, warning = FALSE}
countrydf_merged <- countrydf %>%
  pivot_longer(cols = starts_with("net_per_10K_"),
               names_to = "year",
               names_prefix = "net_per_10K_",
               names_transform = list(year = as.integer),
               values_to = "net_per_10K",
               values_transform = list(net_per_10K = as.double)) %>%
  inner_join(WDIdf,  by = c("base_country_name" = "country", "year")) %>%
  inner_join(WDIdf, by = c("target_country_name" = "country", "year")) %>%
  rename(base_country_GDPpc = GDPpc.x, 
         target_country_GDPpc = GDPpc.y,
         base_country_GDPgrowth = GDPgrowth.x,
         target_country_GDPgrowth = GDPgrowth.y,
         migrationFlux_per10k = net_per_10K) %>% 
  select(year, base_country_code, base_country_name, 
         base_country_GDPpc, base_country_GDPgrowth,
         target_country_code, target_country_name,
         target_country_GDPpc, target_country_GDPgrowth,
         migrationFlux_per10k)
  
#countrydf_merged %>%
#  head(n = 10) %>% 
#  kable(booktabs = T,
#             caption = "First ten rows of the migration flux database.",
#              label = "{tab:migrationFlux}")  %>% 
#  kable_minimal()
```

Now that we have created the dataframe, we can start to investigate the relationship between the migration to a country and its wealth. The first step is to actually whether there is a trend in the destination of the migratory fluxes. To answer this question, Figure \ref{fig:migration_peryear} (left) plots a country's migration flux as a function of its GDP, grouped by year. From the plot we have removed Luxembourg, that is a clear outlier, possibly because of its very small population. What we note from this plot is that there seems to be a positive correlation between migration flux and destination country GDP, suggesting that, as expected, more people tend to emigrate to wealthier countries, where the quality of life expectancy is higher. 

```{r migration_peryear, fig.height=7, fig.width=9.5, fig.show="hold", out.width="50%", echo = FALSE, warning=FALSE, message=FALSE, fig.cap = "Relation between net flux migration of country X expressed as unit per 10k linkedIN users of that country and the country's GDP per capita. The data are grouped by year, and interpolated by means of linear regression. \\label{fig:migration_peryear}"}
  
countrydf_tot <- countrydf_merged %>%
  mutate(base_country_GDPpc = base_country_GDPpc/1000) %>% 
  filter(base_country_code != "lu") %>% 
  group_by(base_country_code, base_country_name, year, base_country_GDPpc) %>% 
  summarise(totalflux = sum(migrationFlux_per10k))

model_list <- lapply(2015:2019, function(y){
  countrydf_tot %>% 
    filter(year == y) %>% 
    lm(totalflux ~base_country_GDPpc, data = .) %>% 
    summary %>% 
    coefficients %>% 
    as.data.frame() %>% 
    select(Estimate, 
           "Std. Error") %>% 
    mutate(year = y) %>% 
    rename(stderr = "Std. Error") %>% 
    tail(1)
})

model_list_sum <- do.call("rbind", lapply(2015:2019, function(y){
  countrydf_tot %>% 
    filter(year == y) %>% 
    lm(totalflux~base_country_GDPpc, data = .) %>% 
    summary %>% 
    glance %>% 
    as.data.frame() %>% 
    select(r.squared, p.value) %>% 
    mutate(year = y)
}))

model_min <- model_list_sum %>% 
  filter(r.squared ==min(r.squared))
model_max <- model_list_sum %>% 
  filter(r.squared ==max(r.squared))

countrydf_tot %>% 
  mutate(year = as.character(year)) %>% 
  ggplot(aes(x = base_country_GDPpc, y = totalflux, color = year)) + 
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  labs(x = "GDP per capita (x10^3)",
       y = "Migration flux (per 10k LinkedIN users)") +
  theme_bw(base_size = 20)

do.call("rbind", model_list) %>% 
  ggplot(aes(x = year, y = Estimate)) +
  geom_segment(aes(x = year, xend = year, y = (Estimate - stderr), 
                   yend = (Estimate + stderr)), 
               color = "darkgray", size = 1.5, alpha = 1) + 
  geom_point(size = 4, color = "#F55D5D") +
  labs(x = "Year", y= "Coefficient") +
  theme_bw(base_size = 20)

```

First of all we should check the significance of this result. We can do so through the p value. The highest value is `r signif(max(model_list_sum$p.value), digits = 2)`, which is well below the threshold of 0.05, implying that this correlation is significant. Then, as a next step, we could estimate the quality of the fit through the R^2^ statistic individually for each year. This is in the range of `r round(model_min$r.squared,2)` for the year `r model_min$year` to `r round(model_max$r.squared,2)` for the year `r model_max$year`. Meaning that whilst the fit is not perfect, it can explain more than the 25% of the data variance. Moreover, it can be noted how the coefficient of the fix seems to be decreasing with time. To have a better picture, Figure \ref{fig:migration_peryear} (right) shows the coefficient together with a 1 std.err. per each year. From such figure we can evince that the decreasing trend seems to be within the 1 std.err. range, making it harder to distinguish from normal fluctuations. More data points will definitely be helpful in clearing up the picture.

To get more insights of the fit, we can plot the histogram of the residuals for the years with the best and worst fit, as shown in Figure \ref{fig:residuals_hist}. As expected we can see that a better fit corresponds to less spread in the histogram of residuals.

```{r residuals_hist, fig.height=7, fig.width=9.5, fig.show="hold", out.width="50%", echo = FALSE, warning=FALSE, message=FALSE, fig.cap = "Histograms of residuals for the year with worst fit (left) and best fit (right). \\label{fig:residuals_hist}"}

countrydf_tot %>% 
  filter(year == model_min$year) %>% 
  lm(totalflux~base_country_GDPpc, data = .) %>% 
  summary %>% 
  residuals %>% 
  as.data.frame() %>% 
  ggplot(aes(.)) +
  geom_histogram(binwidth = 5, fill = I("grey"), col = I("black")) +
  labs(title = paste("year", as.character(model_min$year), sep = " "),
       x = "Residuals") +
  theme_bw(base_size = 20)  +
  theme(plot.title = element_text(hjust = 0.5))

countrydf_tot %>% 
  filter(year == model_max$year) %>% 
  lm(totalflux~base_country_GDPpc, data = .) %>% 
  summary %>% 
  residuals %>% 
  as.data.frame() %>% 
  ggplot(aes(.)) +
  geom_histogram(binwidth = 5, fill = I("grey"), col = I("black")) +
  labs(title = paste("year", as.character(model_max$year), sep = " "),
       x = "Residuals") +
  theme_bw(base_size = 20)  +
  theme(plot.title = element_text(hjust = 0.5))


```

Even though the dataset is quite small, since it includes one point per country per year, we can try to perform a bootstrap anaysis to check whether our data contains some bias. For simplicity, we will only perform this analysis on one single year; to be consistent, we will keep using the year 2015. Then, the bootstrap analysis will compute the linear regression coefficient over a limited dataset that allows repetitions. Here we have performed it for 10000 replicates, and the histogram showing the variation of interpolating coefficients is shown in Figure \ref{fig:bootModel}.

```{r bootModel, fig.height=4.5, fig.width=9.5, echo = FALSE, warning=FALSE, message=FALSE, fig.cap = "Histograms of coefficients when performing a bootstrap analysis of migration flux vs GDP per capita of year 2015, with R = 10000. In red is depicted the interpolating coefficient of the original dataset. \\label{fig:bootModel}"}

originalCoeff <- countrydf_tot %>% 
  filter(year == 2015) %>% 
  lm(totalflux~base_country_GDPpc, data = .) %>% 
  summary %>% 
  coefficients

returnCoeff2 <- function(datav, sampleindices){
  d <- lm(datav$totalflux[sampleindices]~datav$base_country_GDPpc[sampleindices]);
  return (d$coefficients[2])
}
bootResults <- countrydf_tot %>% 
  filter(year == 2015) %>% 
  boot(statistic = returnCoeff2, R = 10000)

bootResults$t %>% 
  as.data.frame() %>% 
  ggplot(aes(x = V1)) +
  geom_histogram(binwidth = 0.03, fill = I("grey"), col = I("black")) +
  labs(x = "Interpolating coefficient") +
  theme_bw(base_size = 15) +
  geom_segment(aes(x = originalCoeff[2], xend = originalCoeff[2],
                   y = 0, yend = 1000),
               colour = "red", size = 1.5)

```
 
From this histogram we can first of all note how the original coefficient is at the center of the gaussian, and how in 100% of cases, the interpolating coefficient is greater than 0. Thus we can comfortably state that there is a correlation between the migration flux and GDPpc of a country. At the same time, however, the distribution is quite wide spread, with a standard deviation of `r round(sd(bootResults$t),2)`. Hence, whilst we can state the presence of a correlation, from this analysis alone, it is hard to quantify the strength of such correlation, as the addition of more data can significantly alter the results.


We have shown how wealthier countries tend to benefit from a larger working migration flux, it is interesting to study whether these countries are benefiting from this larger migratory flux. To do so we can plot the GDP growth as a function of the migration flux of a country. Again, as a first step, we will perform this analysis grouping the countries by year, and, as in the previous analysis, we will exclude Luxembourg, as it is a clear outlier. The results are shown in Figure  \ref{fig:growthVSmigration}. 

```{r growthVSmigration, fig.height=4.5, fig.width=9.5, echo = FALSE, warning=FALSE, message=FALSE, fig.cap = "Plot relating the GDP growth of a country to the migrating flux (per 10k of linkedIN users), for the years 2015 to  2019. The points are fitted through the linear regression method. \\label{fig:growthVSmigration}"}
countrydf_growth <- countrydf_merged %>%
  filter(base_country_code != "lu") %>% 
  group_by(base_country_code, base_country_name, year, base_country_GDPgrowth) %>% 
  summarise(totalflux = sum(migrationFlux_per10k))

model_list_growth<- do.call("rbind", lapply(2015:2019, function(y){
  countrydf_growth %>% 
    filter(year == y) %>% 
    lm(totalflux~base_country_GDPgrowth, data = .) %>% 
    summary %>% 
    glance %>% 
    as.data.frame() %>% 
    select(r.squared, p.value) %>% 
    mutate(year = y)
}))

countrydf_growth %>% 
  mutate(year = as.character(year)) %>% 
  ggplot(aes(y = base_country_GDPgrowth, x = totalflux, color = year)) + 
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  labs(y = "GDP growth (%)", x = "Migration flux (per 10k LinkedIN users)") +
  theme_bw(base_size = 15)
  
```

This plot shows how there does not seem to be any correlation between GDP growth and migration, in fact the interpolating curves are very flat, and have very large residuals. This is confirmed by the p values, as they are all higher than `r round(min(model_list_growth$p.value), 2)`. Moreover, the R^2^ statistics are very low, up to `r round(max(model_list_growth$r.squared),2)`. From this it is possible to conclude that, with only increase of production in mind, it should not be a country's first priority to be more appealing to foreign workers. 

## Industries preferred by migratory workers

To have a deeper look at how migration imapcts the growth of a country, we can also investigate whether a higher migration influx correlates to a larger growth of specific industries. To do so we are going to use again the linkedIN data that depicts the net gain (or loss) of members from (or to) a foreign country, for a specific industry, normalized to the number of linkedIN users, in that industry, in that country. These industries are gouped in different ISIC sections [citation needed]. The aim of this section is to verify whether net migration flux correlates to a larger growth of one of these sections. We are going to carry on this analysis for only one year, that is 2015.

Figure \ref{fig:growthVSmigration2} (left) depicts the data points grouped per ISIC section index, fitted through linear regression. Then, Figure \ref{fig:growthVSmigration2} (right) shows the slope of such interpolations, together with 1 std. error.

```{r growthVSmigration2, fig.height=7, fig.width=9.5, fig.show="hold", out.width="50%", echo = FALSE, warning=FALSE, message=FALSE, fig.cap = "Industry growth due to migration as a function of net migration in the year 2019. \\label{fig:growthVSmigration2}"}

countrysumm_df <- countrydf_merged %>% 
  filter(year == 2015, !base_country_code %in% c("lu", "ch")) %>% 
  group_by(base_country_code, base_country_GDPpc, base_country_GDPgrowth) %>% 
  summarise(migrationFlux = sum(migrationFlux_per10k)) %>% 
  rename(GDPpc = base_country_GDPpc,
         GDPgrowth = base_country_GDPgrowth)
consideredIndustries = c("I", "N", "R", "D", "Q", "C", "A", "B", "K", "G", "H", "F")

industryGrowth_df <- industrydf %>% 
  filter(isic_section_index %in% consideredIndustries) %>%
  inner_join(countrysumm_df, by = c("country_code" = "base_country_code")) %>% 
  group_by(isic_section_index, isic_section_name, GDPpc, country_code, GDPgrowth, migrationFlux) %>% 
  summarise(growth = mean(net_per_10K_2015)) %>% 
  mutate(isic_section_name = paste(isic_section_index, isic_section_name, sep = "-"))

industryGrowth_df %>% 
  ggplot(aes(x = migrationFlux, y = growth, color = isic_section_index)) + 
  geom_point() +
  geom_smooth(method = "lm", se = F) +
  labs(x = "Migration flux (per 10k)") +
  labs(y = "Industry growth(per 10k)") +
  theme_bw(base_size = 20)

industryGrowthvsM_lm2019 <- industryGrowth_df %>% 
  group_by(isic_section_name) %>% 
  do(glance(lm(growth~migrationFlux, data = .))) %>% 
  select(r.squared, statistic)

model_list_industry <- lapply(consideredIndustries, function(i){
  industryGrowth_df %>% 
    filter(isic_section_index == i) %>% 
    lm(growth~migrationFlux, data = .) %>% 
    summary %>% 
    coefficients %>% 
    as.data.frame() %>% 
    select(Estimate, 
           "Std. Error") %>% 
    mutate(isic_section_index = i) %>% 
    rename(stderr = "Std. Error") %>% 
    tail(1)
})

model_list_industry_sum <- do.call("rbind", lapply(consideredIndustries, function(i){
  industryGrowth_df %>% 
    filter(isic_section_index == i) %>% 
    lm(growth~migrationFlux, data = .) %>% 
    summary %>% 
    glance %>% 
    as.data.frame() %>% 
    select(r.squared, p.value) %>% 
    mutate(isic_sector = i)
}))

do.call("rbind", model_list_industry) %>% 
  ggplot(aes(x = isic_section_index, y = Estimate)) +
  geom_segment(aes(x = isic_section_index, xend = isic_section_index, y = (Estimate - stderr), 
                   yend = (Estimate + stderr)), 
               color = "darkgray", size = 1.5, alpha = 1) + 
  geom_point(size = 4, color = "#F55D5D") +
  labs(x = "Isic Section Index", y= "Coefficient") +
  theme_bw(base_size = 20)

model_list_industry_sum %>%
  kable(booktabs = T,
               caption = "R squared and p values for the fit of industry growth due to migration vs migration flux.    \\label{tab:industryGrowth}")  %>% 
  kable_minimal()

```

We can notice how the B, C and D sectors are lower than the others. These are Quarrying, Manufacturing and Energy respectively. On the other side, there is a stronger correlation with the sections F, I, R, which are Construction, Accomodation and Arts & Entertainment respectively. It is also important to notice that the industry growth due to foreigners can go up to a non-negligible 3%. With this in mind, incentivating a working migratory flux can help a country in develop certain industry sectors, that would otherwise be less populated.

The p values and R^2^ values are shown in table \ref{tab:industryGrowth}. All p values are below the 0.05 threshold.Moreover, the sectors A and F have a very large std.err., meaning that there is probably more variability across the countries, and a correlation with the migration flux alone is not enough.

## Limitations

When doing such an analysis is it also important to identify where the limitations are. The first, most obvious one, is that this data has been normalized to the number of LinkedIN users for each country. We could not cross-validate this data with other employment datasets. Still, according to the source, this data has already been validated with 23 other external datasets.
Moreover, these data do not include any differentiation such as gender or age. It would be interesting to investigate how migration fluxes differ for these categories.

